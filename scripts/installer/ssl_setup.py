#!/usr/bin/env python3
"""
TSiJUKEBOX Enterprise - SSL Setup v6.0.0
=========================================
Configuração de certificados SSL para HTTPS.

Autor: B0.y_Z4kr14
Licença: Domínio Público
"""

import subprocess
import shutil
from pathlib import Path
from typing import List, Tuple, Optional
from dataclasses import dataclass


@dataclass
class SSLConfig:
    """Configuração de SSL."""
    domain: str = "midiaserver.local"
    email: str = ""
    use_letsencrypt: bool = False
    ssl_dir: Path = Path("/etc/nginx/ssl")
    cert_days: int = 365
    key_size: int = 2048


class SSLSetup:
    """Configura certificados SSL."""
    
    def __init__(self, config: Optional[SSLConfig] = None, logger=None, dry_run: bool = False):
        self.config = config or SSLConfig()
        self.logger = logger
        self.dry_run = dry_run
    
    def _log(self, level: str, msg: str):
        if self.logger:
            getattr(self.logger, level, print)(msg)
        else:
            print(f"[{level.upper()}] {msg}")
    
    def _run_command(self, cmd: List[str]) -> Tuple[int, str, str]:
        if self.dry_run:
            self._log('info', f"[DRY-RUN] {' '.join(cmd)}")
            return 0, "", ""
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return result.returncode, result.stdout, result.stderr
        except Exception as e:
            return 1, "", str(e)
    
    def generate_self_signed(self) -> bool:
        """Gera certificado auto-assinado para uso local."""
        self._log('info', f"Gerando certificado auto-assinado para {self.config.domain}")
        
        ssl_dir = self.config.ssl_dir
        if not self.dry_run:
            ssl_dir.mkdir(parents=True, exist_ok=True)
        
        key_file = ssl_dir / f"{self.config.domain}.key"
        cert_file = ssl_dir / f"{self.config.domain}.crt"
        
        # Generate private key and certificate
        cmd = [
            'openssl', 'req', '-x509', '-nodes',
            '-days', str(self.config.cert_days),
            '-newkey', f'rsa:{self.config.key_size}',
            '-keyout', str(key_file),
            '-out', str(cert_file),
            '-subj', f'/CN={self.config.domain}/O=TSiJUKEBOX/C=BR/ST=Sao Paulo/L=Sao Paulo'
        ]
        
        code, _, err = self._run_command(cmd)
        
        if code != 0:
            self._log('error', f"Falha ao gerar certificado: {err}")
            return False
        
        # Set permissions
        if not self.dry_run:
            key_file.chmod(0o600)
            cert_file.chmod(0o644)
        
        self._log('success', f"Certificado gerado: {cert_file}")
        return True
    
    def setup_letsencrypt(self) -> bool:
        """Configura Let's Encrypt com certbot."""
        if not self.config.email:
            self._log('error', "Email é obrigatório para Let's Encrypt")
            return False
        
        self._log('info', f"Configurando Let's Encrypt para {self.config.domain}")
        
        # Install certbot
        code, _, _ = self._run_command(['pacman', '-S', '--noconfirm', '--needed', 'certbot', 'certbot-nginx'])
        if code != 0:
            self._log('warning', "Falha ao instalar certbot, tentando via pip...")
            self._run_command(['pip', 'install', 'certbot', 'certbot-nginx'])
        
        # Run certbot
        cmd = [
            'certbot', '--nginx',
            '-d', self.config.domain,
            '--email', self.config.email,
            '--agree-tos',
            '--non-interactive',
            '--redirect'
        ]
        
        code, out, err = self._run_command(cmd)
        
        if code != 0:
            self._log('error', f"Falha ao obter certificado: {err}")
            return False
        
        # Setup auto-renewal
        self._run_command(['systemctl', 'enable', 'certbot-renew.timer'])
        self._run_command(['systemctl', 'start', 'certbot-renew.timer'])
        
        self._log('success', "Let's Encrypt configurado com renovação automática")
        return True
    
    def create_nginx_ssl_config(self) -> str:
        """Gera configuração SSL para Nginx."""
        ssl_dir = self.config.ssl_dir
        domain = self.config.domain
        
        return f"""# SSL Configuration for {domain}
# Generated by TSiJUKEBOX Installer

server {{
    listen 80;
    server_name {domain};
    return 301 https://$host$request_uri;
}}

server {{
    listen 443 ssl http2;
    server_name {domain};
    
    # SSL Certificates
    ssl_certificate {ssl_dir}/{domain}.crt;
    ssl_certificate_key {ssl_dir}/{domain}.key;
    
    # SSL Configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    
    # Security Headers
    add_header Strict-Transport-Security "max-age=63072000" always;
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    
    # Main application
    location / {{
        proxy_pass http://127.0.0.1:5173;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }}
    
    # Grafana
    location /grafana/ {{
        proxy_pass http://127.0.0.1:3000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }}
    
    # Prometheus
    location /prometheus/ {{
        proxy_pass http://127.0.0.1:9090/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }}
    
    # API
    location /api/ {{
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }}
}}
"""
    
    def full_setup(self) -> bool:
        """Executa configuração completa de SSL."""
        # Choose method based on domain
        if self.config.use_letsencrypt and self.config.email:
            success = self.setup_letsencrypt()
        else:
            success = self.generate_self_signed()
        
        if not success:
            return False
        
        # Generate and save nginx config
        nginx_config = self.create_nginx_ssl_config()
        nginx_file = Path("/etc/nginx/sites-available") / f"{self.config.domain}.conf"
        
        if not self.dry_run:
            nginx_file.parent.mkdir(parents=True, exist_ok=True)
            nginx_file.write_text(nginx_config)
            
            # Create symlink
            sites_enabled = Path("/etc/nginx/sites-enabled")
            sites_enabled.mkdir(parents=True, exist_ok=True)
            link = sites_enabled / f"{self.config.domain}.conf"
            if not link.exists():
                link.symlink_to(nginx_file)
        
        # Test and reload nginx
        code, _, err = self._run_command(['nginx', '-t'])
        if code == 0:
            self._run_command(['systemctl', 'reload', 'nginx'])
            self._log('success', "SSL configurado e Nginx recarregado")
        else:
            self._log('warning', f"Configuração Nginx inválida: {err}")
        
        return True


def main():
    """Teste do módulo SSL."""
    config = SSLConfig(domain="midiaserver.local")
    ssl = SSLSetup(config=config, dry_run=True)
    ssl.full_setup()


if __name__ == "__main__":
    main()
